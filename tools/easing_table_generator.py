#!/usr/bin/python
# ----------------------------------------------------------------------------
# Easing Table Generator
# (c) 2015 Ricardo Quesada
# ----------------------------------------------------------------------------
'''
Easing Table Generator
'''
from __future__ import division, unicode_literals, print_function
import sys
import os
import getopt
import math
import inspect


__docformat__ = 'restructuredtext'


def cubic_bezier_at(t, a, b, c, d):
    return (
        ((1-t)**3) * a +
        3 * ((1-t)**2) * t * b +
        3 * (1-t) * (t**2) * c +
        (t**3) * d
        )


def fn_bezier(time, a, b, c, d):
    return cubic_bezier_at(time, a, b, c, d)


def fn_easeInSine(time):
    # return -1 * math.cos(time * math.pi/2) + 1
    # cubic-bezier(0.47, 0, 0.745, 0.715)
    return cubic_bezier_at(time, 0, 0, 0.715, 1)


def fn_easeOutSine(time):
    # return math.sin(time * math.pi/2)
    # cubic-bezier(0.39, 0.575, 0.565, 1);
    return cubic_bezier_at(time, 0, 0.575, 1, 1)


def fn_easeInOutSine(time):
    # return -0.5 * (math.cos(math.pi * time) - 1)
    # cubic-bezier(0.445, 0.05, 0.55, 0.95);
    return cubic_bezier_at(time, 0, 0.05, 0.95, 1)


def fn_easeInQuad(time):
    # return time * time
    # cubic-bezier(0.55, 0.085, 0.68, 0.53);
    return cubic_bezier_at(time, 0, 0.085, 0.53, 1)


def fn_easeOutQuad(time):
    # return -1 * time * (time - 2)
    # cubic-bezier(0.25, 0.46, 0.45, 0.94);
    return cubic_bezier_at(time, 0, 0.46, 0.94, 1)


def fn_easeInOutQuad(time):
    # time = time * 2
    # if time < 1:
    #     return 0.5 * time * time
    # time = time - 1
    # return -0.5 * (time * (time - 2) - 1)
    # cubic-bezier(0.455, 0.03, 0.515, 0.955);
    return cubic_bezier_at(time, 0, 0.03, 0.955, 1)


def fn_easeInCubic(time):
    # return time * time * time
    # cubic-bezier(0.55, 0.055, 0.675, 0.19);
    return cubic_bezier_at(time, 0, 0.055, 0.19, 1)


def fn_easeOutCubic(time):
    # time = time - 1
    # return (time * time * time + 1)
    # cubic-bezier(0.215, 0.61, 0.355, 1);
    return cubic_bezier_at(time, 0, 0.61, 1, 1)


def fn_easeInOutCubic(time):
    # time = time * 2
    # if time < 1:
    #     return 0.5 * time * time * time
    # time = time - 2
    # return 0.5 * (time * time * time + 2)
    # cubic-bezier(0.645, 0.045, 0.355, 1);
    return cubic_bezier_at(time, 0, 0.045, 1, 1)

def parseArgs(formula):
    # valid formula formats:
    #  - 'easeInSine'
    #  - 'easeInOutSine:'
    #  - 'bezier:0,0.1,0.93,1'
    args_float = None
    l = formula.split(':')
    formula_name = l[0]
    if len(l) == 2:
        args = l[1]
        # it might have multiple args separated by ','
        args = args.split(',')
        args_float = [float(x) for x in args]
    formula_name = 'fn_' + formula_name
    if not args_float:
        args_float = []
    return formula_name, args_float


def printList(l):
    for i, item in enumerate(l):
        if i % 8 == 0:
            sys.stdout.write('\n.byte $%02x' % item)
        else:
            sys.stdout.write(',$%02x' % item)
    sys.stdout.write('\n')


def run(formula, steps, maxvalue, reverse):
    formula_name, args = parseArgs(formula)
    print(formula_name, args)
    try:
        fn = getattr(sys.modules[__name__], formula_name)
    except AttributeError, e:
        raise Exception("Invalid formula name: %s" % formula)
    l = []

    for i in xrange(steps):
        # does not include time=0, but includes time=1
        ret = fn((i+1)/steps,*args)
        l.append(int(round(ret * float(maxvalue))))

    # print 8 elements per line
    sys.stdout.write('; autogenerated table. function=%s, table size=%d, values range=(0,%d)' % (formula, int(steps), int(maxvalue)))
    printList(l)

    # reverse ?
    if reverse:
        # reverse list
        l.reverse()
        # remove first element, when time == 1
        del l[0]
        # append new element, when time == 0
        ret = fn(0,*args)
        l.append(int(round(ret * float(maxvalue))))

        sys.stdout.write('; reversed')
        printList(l)


def list_formulas():
    l = dir(sys.modules[__name__])
    formulas = [x[3:] for x in l if x.startswith('fn_')]
    print("Valid formulas:")
    for f in formulas:
        print("\t%s" % f)


def help():
    print("%s v0.1 - An utility to create easing tables. Useful for c64 and other 8-bit computers" % os.path.basename(sys.argv[0]))
    print("\nUsage: %s [options] formula_name" % os.path.basename(sys.argv[0]))
    print("\t-s tablesize\t\t\ttable size. default=256")
    print("\t-m maxvalue\t\t\tmax value for the table. default=128")
    print("\t-r\t\t\t\twill also generate the reversed table")
    print("\t-f\t\t\t\tlist available formulas")
    print("\t-a\t\t\t\tadditional args for bezier")
    print("\tformula_name\t\t\tuse -f to list the available formulas")
    print("\nExamples:")
    print("\t%s -s256 -m90 easeInSine" % os.path.basename(sys.argv[0]))
    print("\t%s -s128 -m40 -r easeInOutCubic" % os.path.basename(sys.argv[0]))
    print("\t%s -s128 -m40 -r bezier:0,0.2,0.8,1" % os.path.basename(sys.argv[0]))
    print("\t%s -f" % os.path.basename(sys.argv[0]))
    sys.exit(-1)


if __name__ == "__main__":
    if len(sys.argv) == 1:
        help()

    formula = None
    steps = 256
    maxvalue = 128
    reverse = False

    argv = sys.argv[1:]
    try:
        opts, args = getopt.getopt(argv, "fs:m:r", ["formulas", "tablesize=", "maxvalue=", "reverse"])
        for opt, arg in opts:
            if opt in ("-f", "--formulas"):
                list_formulas()
                exit(0)
            elif opt in ("-s", "--tablesize"):
                steps = int(arg)
            elif opt in ("-m", "--maxvalue"):
                maxvalue = arg
            elif opt in ("-r", "--reverse"):
                reverse = True
        if len(args) > 1 or len(args) == 0:
            help()
        else:
            formula = args[0]
    except getopt.GetoptError, e:
        print(e)

    run(formula, steps, maxvalue, reverse)
